---
title: "Nothing to see here yet"
date: 2024-09-13
tags: [posts]
excerpt: "Nothing to see here yet"
toc: true
toc_label: "Table of Contents"
toc_icon: "list-ul"
toc_sticky: true
---
<img src="{{ site.url }}{{ site.baseurl }}/images/title_image.png" alt="">

## Introduction

Recently I have been working on an un-published (at this time) blog post that will look at how `securekernel.exe` and `ntoskrnl.exe` work together in order to enable and support the Kernel Control Flow Guard (Kernel CFG) feature, which is enabled under certain circumstances on modern Windows systems. This comes from the fact that I have recently been receiving questions from others on this topic. During the course of my research, I realized that a relatively-unknown topic that kept reappearing in my analysis was the concept of Normal Address Ranges (NARs) and Normal Address Table Entries (NTEs), sometimes referred to as NT Address Ranges or NT Address Table Entries. The only mention I have seen of these terms comes from _Windows Internals 7th Edition, Part 2, Chapter 9_, which [was written](https://x.com/aall86/status/1769795201415954442) by Andrea Allievi. The more I dug in, the more I realized this topic could probably use its own blog post.

However, when I started working on _that_ blog post I realized that the concept of "Secure Image Objects" also plays into NAR and NTE creation. Because of this, I realized I maybe could just start with Secure Image objects!

Given the lack of debugging capabilities for `securekernel.exe`, lack of user-defined types (UDTs) in the `securekernel.exe` symbols, and overall lack of public information, there is no way (as we will see) I will be able to completely map Secure Image objects back to absolute structure definitions (and the same goes with NAR/NTEs). This blog (and subsequent ones) are really just analysis posts outlining things such as Secure System Calls, functionality, the reverse engineering methodology I take, etc. I am not an expert on this subject matter (like Andrea, Satoshi Tanda, or others) and mainly writing up my analysis for the sheer fact there isn't too much information out there on these subjects and I also greatly enjoy writing long-form blog posts. With that said, the "song-and-dance" performed between NT and Secure Kernel to load images/share resources/etc. is a very complex (in my mind) topic. The terms I use are based on the names of the functions, and may differ from the actual terms as an example. So please feel free to reach out with improvements/corrections. Lastly, Secure Image objects can be created for other images other than drivers. We will be focusing on driver loads. With this said, I hope you enjoy!

## SECURE_IMAGE Overview

_Windows Internals, 7th Edition, Chapter 9_ gives a brief mention of `SECURE_IMAGE` objects:

Given the lack of debugging capabilities for `securekernel.exe`, lack of user-defined types (UDTs) in the `securekernel.exe` symbols, and overall lack of public information, there is no way (as we will see) I will be able to completely map Secure Image objects back to absolute structure definitions (and the same goes with NAR/NTEs). This blog (and subsequent ones) are really just analysis posts outlining things such as Secure System Calls, functionality, the reverse engineering methodology I take, etc. I am not an expert on this subject matter (like Andrea, Satoshi Tanda, or others) and mainly writing up my analysis for the sheer fact there isn't too much information out there on these subjects and I also greatly enjoy writing long-form blog posts. With that said, the "song-and-dance" performed between NT and Secure Kernel to load images/share resources/etc. is a very complex (in my mind) topic. The terms I use are based on the names of the functions, and may differ from the actual terms as an example. So please feel free to reach out with improvements/corrections. Lastly, Secure Image objects can be created for other images other than drivers. We will be focusing on driver loads. With this said, I hope you enjoy!

## IMAGE Overview

_Windows Internals, 7th Edition, Chaptdffdfdfd a brief mention of `SECURE_IMAGE` objects:

Given the lack of debugging capabilities for `securekernel.exe`, lack of user-defined types (UDTs) in the `securekernel.exe` symbols, and overall lack of public information, there is no way (as we will see) I will be able to completely map Secure Image objects back to absolute structure definitions (and the same goes with NAR/NTEs). This blog (and subsequent ones) are really just analysis posts outlining things such as Secure System Calls, functionality, the reverse engineering methodology I take, etc. I am not an expert on this subject matter (like Andrea, Satoshi Tanda, or others) and mainly writing up my analysis for the sheer fact there isn't too much information out there on these subjects and I also greatly enjoy writing long-form blog posts. With that said, the "song-and-dance" performed between NT and Secure Kernel to load images/share resources/etc. is a very complex (in my mind) topic. The terms I use are based on the names of the functions, and may differ from the actual terms as an example. So please feel free to reach out with improvements/corrections. Lastly, Secure Image objects can be created for other images other than drivers. We will be focusing on driver loads. With this said, I hope you enjoy!
